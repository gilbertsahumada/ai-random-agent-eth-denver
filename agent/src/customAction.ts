import {
    HandlerCallback,
    IAgentRuntime,
    Memory,
    State,
    type Action,
} from "@elizaos/core";
import { elizaLogger } from "@elizaos/core";
import { BlockchainService } from "./services/BlockchainService";
import { AudioService } from "./services/AudioService";
import { IPFSService } from "./services/IPFSService";
import { PodcastPrompt, PodcastMetadata } from "./interfaces/Podcast";
import { Anthropic } from '@anthropic-ai/sdk';
import { extractMessages } from "./utils/utils";

export const generatePodcast: Action = {
    name: "GENERATE_SPEECH",
    similes: [],
    description: "Generate a podcast with VRF randomization and mint it as NFT",

    validate: async (_agent: IAgentRuntime, _memory: Memory, _state?: State) => {
        const messages = extractMessages(_memory.content.text);
        if (!messages) return false;

        if (_state) {
            _state.daily_messages = messages;
            return true;
        }
        return false;
    },

    handler: async (_agent: IAgentRuntime, _memory: Memory, _state?: State, _options?: any, _callback?: HandlerCallback) => {
        if (!_callback) throw new Error("Callback is required");
        const messages = extractMessages(_memory.content.text);

        try {
            // Initialize services
            const blockchainService = new BlockchainService(
                process.env.EVM_PRIVATE_KEY!,
                process.env.CONTRACT_ADDRESS!
            );

            const audioService = new AudioService(process.env.ELEVENLABS_XI_API_KEY!);
            const ipfsService = new IPFSService(process.env.PINATA_JWT!);

            // Get Random parameters
            _callback({ text: "Requesting random parameters from Chainlink VRF..." });
            const randomParams = await blockchainService.requestRandomParameters();

            // Generate text content
            _callback({ text: "Generating podcast content..." });
            const content = await generatePodcastContent(
                messages ? messages : ["Awesome messages!"],
                randomParams,
                process.env.ANTHROPIC_API_KEY!
            );

            // Generate audio
            _callback({ text: "Converting text to speech..." });
            const audioPath = await audioService.generateAudio(content);

            // Upload to IPFS
            _callback({ text: "Uploading to IPFS..." });
            const audioHash = await ipfsService.uploadAudioFile(audioPath);

            const metadata: PodcastMetadata = {
                name: "BuffiCast Podcast",
                description: `Podcast generated by BuffiCast with parameters: ${JSON.stringify(randomParams)}`,
                image: "https://ipfs.io/ipfs/bafkreifqzkq7tzppc22fa2f52sg2cruvomne2tp34yhdnx3ub2xw24b52m",
                external_url: `https://ipfs.io/ipfs/${audioHash}`
            };

            const metadataHash = await ipfsService.uploadMetadata(metadata);

            // Update token URI
            _callback({ text: "Updating NFT metadata..." });
            await blockchainService.updateTokenURI(`https://ipfs.io/ipfs/${metadataHash}`);

            _callback({ text: "Podcast generated and minted successfully! Check OpenSea to view your NFT." });
            return true;

        } catch (error) {
            elizaLogger.error("Podcast Generation Error:", error);
            _callback({ text: "An error occurred while generating the podcast." });
            return false;
        }
    },

    examples: [
        [
            {
                user: "{{user1}}",
                content: { text: `create me a speech "eth denver is awesome", "bufficast project is the best"` }
            },
            {
                user: "{{agentName}}",
                content: { text: "Let me do it for you!!", action: "GENERATE_SPEECH" }
            }
        ],
        [
            {
                user: "{{user1}}",
                content: { text: `Create me a podcast "ethereum is great", "avalanche is great", "solana sucks"` }
            },
            {
                user: "{{agentName}}",
                content: { text: "I'll start to create!", action: "GENERATE_SPEECH" }
            }
        ]
    ]
};

async function generatePodcastContent(messages: string[], randomParams: any, apiKey: string): Promise<string> {
    const anthropic = new Anthropic({ apiKey });
    const prompt: PodcastPrompt = {
        instruction: "Generate a podcast script based on the day's messages. Create natural speech without formatting.",
        topic: "Ethereum Denver 2025 daily podcast",
        daily_messages: messages,
        random_parameters: randomParams,
        duration: "30 Seconds",
        language: "English"
    };

    const response = await anthropic.messages.create({
        model: "claude-3-haiku-20240307",
        max_tokens: 1024,
        messages: [{ role: "user", content: JSON.stringify(prompt) }],
    });

    return response.content
        .filter(block => block.type === 'text')
        .map(block => (block as { type: 'text'; text: string }).text)
        .join('\n');
}



